(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{509:function(v,t,_){"use strict";_.r(t);var a=_(55),e=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"vue是如何做到数据响应的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue是如何做到数据响应的"}},[v._v("#")]),v._v(" Vue是如何做到数据响应的？")]),v._v(" "),_("h2",{attrs:{id:"vue的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期"}},[v._v("#")]),v._v(" Vue的生命周期")]),v._v(" "),_("p",[v._v("总共分为8个阶段")]),v._v(" "),_("ol",[_("li",[v._v("创建前: vue实例的"),_("strong",[v._v("挂载元素el")]),v._v("和"),_("strong",[v._v("数据data")]),v._v("都为"),_("code",[v._v("undefined")]),v._v(",尚未初始化")]),v._v(" "),_("li",[v._v("创建后: "),_("strong",[v._v("数据对象data")]),v._v("有了，"),_("strong",[v._v("挂载元素")]),v._v("仍然未初始化。")]),v._v(" "),_("li",[v._v("挂载前: 挂载元素和数据对象都初始化了，但此时挂载元素为"),_("strong",[v._v("虚拟节点")]),v._v("，"),_("code",[v._v("data.message")]),v._v("还未替换。")]),v._v(" "),_("li",[v._v("挂载后: 实例元素挂载成功，data.message成功渲染。")]),v._v(" "),_("li",[v._v("更新前/后: 当数据发生变化的时候，会触发 beforeUpdate和updated方法。")]),v._v(" "),_("li",[v._v("销毁前/后: 执行"),_("code",[v._v("destory")]),v._v("方法后，对data的改变不会再"),_("strong",[v._v("触发")]),v._v("周期函数，说明此时vue实例已经"),_("strong",[v._v("解除")]),v._v("了"),_("strong",[v._v("事件监听")]),v._v("以及和"),_("strong",[v._v("dom的绑定")]),v._v("，但是"),_("strong",[v._v("dom结构依然存在")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"v-if和v-show"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v-if和v-show"}},[v._v("#")]),v._v(" v-if和v-show")]),v._v(" "),_("ol",[_("li",[v._v("v-if在切换时，会对标签进行适当的 "),_("strong",[v._v("销毁")]),v._v("与 "),_("strong",[v._v("创建")]),v._v(",而v-show只会在初次加载时进行 "),_("strong",[v._v("创建")]),v._v("。因此v-if的 "),_("strong",[v._v("开销")]),v._v(" 相对于 v-show来讲，会大得多。")]),v._v(" "),_("li",[v._v("v-if是 "),_("strong",[v._v("惰性")]),v._v(" 的，只有条件为真时才会真正渲染。如果条件不为真，则不去渲染标签。而v-show始终渲染,它的布尔值只是"),_("code",[v._v("display:none")]),v._v("与"),_("code",[v._v("display:block")]),v._v("的开关而已。")])]),v._v(" "),_("h2",{attrs:{id:"computed和watch的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#computed和watch的区别"}},[v._v("#")]),v._v(" computed和watch的区别")]),v._v(" "),_("h3",{attrs:{id:"计算属性computed"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算属性computed"}},[v._v("#")]),v._v(" 计算属性computed")]),v._v(" "),_("ol",[_("li",[v._v("支持缓存，只有数据发生改变时，才会重新进行计算。")]),v._v(" "),_("li",[v._v("不支持异步，在"),_("code",[v._v("computed")]),v._v("中进行异步操作均无效，无法监听数据的变化")]),v._v(" "),_("li",[v._v("如果一个属性是有其他属性计算而来的，这个属性以来其他属性，以一个多对一或者一对一，一般用computed。")]),v._v(" "),_("li",[v._v("computed属性值会默认走缓存")])]),v._v(" "),_("h2",{attrs:{id:"vue双向绑定原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue双向绑定原理"}},[v._v("#")]),v._v(" Vue双向绑定原理")]),v._v(" "),_("h2",{attrs:{id:"父子通信-兄弟通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#父子通信-兄弟通信"}},[v._v("#")]),v._v(" 父子通信，兄弟通信")]),v._v(" "),_("h2",{attrs:{id:"讲一讲vuex"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#讲一讲vuex"}},[v._v("#")]),v._v(" 讲一讲Vuex")])])}),[],!1,null,null,null);t.default=e.exports}}]);